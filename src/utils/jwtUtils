// src/utils/jwtUtils.js

/**
 * Prüft, ob ein JWT-Token abgelaufen oder ungültig ist.
 * - Versucht NICHT zu decodieren, wenn kein/leer/ungültiges Format vorliegt.
 * - Wirft keine Exceptions (atob/JSON), sondern liefert in Fehlerfällen true zurück.
 */
export function isTokenExpired(token) {
  // Kein Token oder kein String -> als abgelaufen behandeln
  if (!token || typeof token !== "string" || token.trim().length === 0) {
    return true;
  }

  // Muss aus genau drei Teilen bestehen: header.payload.signature
  const parts = token.split(".");
  if (parts.length !== 3) {
    return true;
  }

  try {
    // payload (Base64URL) sicher decodieren
    const base64Url = parts[1];
    // Base64URL -> Base64
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    // Padding auffüllen (mod 4)
    const padding = "=".repeat((4 - (base64.length % 4)) % 4);
    const payloadJson = atob(base64 + padding);

    const payload = JSON.parse(payloadJson);
    // exp muss eine Zahl (Sekunden seit Epoch) sein
    if (!payload || typeof payload.exp !== "number") {
      return true;
    }

    const nowMs = Date.now();
    const expMs = payload.exp * 1000; // exp ist Sekunden -> ms
    return expMs <= nowMs;
  } catch (_) {
    // Ungültig/korrupt -> als abgelaufen behandeln, aber nicht crashen
    return true;
  }
}

/*
// src/utils/jwtUtils.js
export function isTokenExpired(token) {
  if (!token) return true;
  try {
    const payload = JSON.parse(atob(token.split('.')[1]));
    const now = Math.floor(Date.now() / 1000);
    return payload.exp < now;
  } catch (e) {
    console.error("Ungültiger Token:", e);
    return true;
  }
}
*/